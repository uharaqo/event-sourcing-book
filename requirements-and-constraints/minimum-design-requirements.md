# Minimum Design Requirements

## Overview

A command is an input from outside the system. Events contain all the information we want to persist. A state is recovered from events and only used by command handlers.

The system receives a command and looks up the command handler for that. It may read events to recover zero or more states. It generates zero or more events, or rejects the command. The emitted events are persisted in a database. If another event that has the same ID and version, the write request gets rejected and the command handler fails. Projections can read these events to make side effects such as updating databases or sending events to external systems.

### Event

An event is an immutable record persisted in a database. Since basically we only keep events in a database, events contain all the information we needed in the past. Each event should at least have an event group, state ID, monotonously increasing version number, and data that represents a state transition. Example: group: `cart`, id: `cartId-123` , version: `5`, content: `{"_name": "ItemAdded", "itemId": 41, "count": 2}`

### Event Group

An event group literary groups events. Event versions inside a single event group with the same state ID should monotonously increase in the insertion order.

Insertion order of events across multiple event groups is not accurately preserved though it can be roughly sorted by timestamps. (In general, clocks are not accurate.)

### Projection

An event consumer. Projections can be used to run side effects based on persisted events (e.g. updating a table, sending an email). Since each event is immutable and has a unique version, they can be safely consumed concurrently as many times as required. Typically, projections are handled by separate processes for scalability and designed as eventual consistency and at-least-once semantics.

### Command

An input from outside the system. It's a request to change the system's internal state or makes side effects. The content is mostly the same as typical HTTP POST / PUT requests.

### Command Handler

Recieves a command and generate events or rejects the command. It may consume states or call external systems. We have no constraints for command handlers at this point.&#x20;

### Event Handler

Generates the next state by consuming the next event and the previous state. The function should not depend on external data for repeatable state recovery. A predefined initial state and an event v1 generate a state v1, and the state v1 and an event v2 generate state v2, and so on. This state recovery process can be regarded as a kind of projection.

### State

In the context of Event Sourcing, a state is data that is consumed by a command handler. Unlike traditional systems, a state is not directly stored in a database but gets generated by replaying events by using the event handler for the state.
