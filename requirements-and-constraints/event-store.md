# Event Store

## Overview

An event store is a storage that preserves events. Design of the event store defines the capability of the entire Event Sourcing system.

## Event Reads

There are mainly two types of queries.

### State Query (event group and id)

A state is often required to handle a command. The state gets generated by aggregating all events for the state. Query example:

`SELECT version, data FROM event WHERE group = 'user' and id = 'user123' ORDER BY version;`

### Projection Query (event groups)

A projection reads a group of events. Since a projection does not know persisted IDs in advance, it needs to scan through events. Query example:

`SELECT id, version, data FROM event WHERE group = 'user' ORDER by version;`

The version can be used to record the position of the event consumption.

### (Optional) Projection Query for multiple event groups

When multiple groups of events need to be consumed by a single projection, the above projection query is not sufficient because events can only be sorted by versions within each event group. This can be supported by adding an sequential ID or unique timestamp. Example:

`SELECT group, id, timestamp, data FROM event WHERE group IN ('user', 'group') ORDER by timestamp;`

Note that the order of events across multiple groups is not always guaranteed. For instance, Event 1 that happened in a group might be written after Event 2 in another group though Event 1 was generated earlier than Event 2.

## Event Write

### Data Schema

An example table definition for Postgresql:

```
CREATE TABLE IF NOT EXISTS event (
  group      TEXT         NOT NULL,
  id         TEXT         NOT NULL,
  version    BIGINT       NOT NULL,
  data       JSONB        NOT NULL,
  seq        BIGSERIAL    NOT NULL UNIQUE,
  created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC'),
  PRIMARY KEY (group, id, version)
);
```

An insert query would look like this:

```
INSERT INTO event (
  group, id, version, data
) VALUES (
  'user', 'user123', 3, '{"_name": "EmailUpdated", "email": "foo@..."}'
);
```

This simple query is sufficient enough to satisfy the requirement. Since events are immutable and written only once, we don't need complex concurrency control for this purpose. This functionality would be supported by most databases.

### (Optional) Atomic Write

An atomic batch write is required to support writing multiple events generated from a single command. This is supported by RDBMS as `INSERT INTO event (...) VALUES (...), (...);`.  But not all databases support this feature. For example, though Cassandra supports a batch write and conditinoal insertion, both of them can be only used for a single partition.

### (Optional) Transactions

Most articles say "Event Sourcing systems need to be designed by accepting eventual consistency" and assume no usage of ACID transactions. This is not necessarily true.

As mentioned above, event conflicts can be easily prevented even without transactions. Transactions are required to control command handlers. The details are discussed in[command-handlers-and-side-effects.md](command-handlers-and-side-effects.md "mention").

### (Optional) Snapshot

For performance and efficiency, a state snapshot can be persisted separately. In this case, the consumer needs to make at least two queries: a snapshot read and succeeding event reads.

## Summary

Event Sourcing need complex concurrency control and state managementWith the simple constraint, immutability of events, . Since we only have a single data schema, replicating the database is quite easy. This is&#x20;

* The event store can be easily cloned to a local machine or container. We can easily debug and test features with production data. A new feature can be tested locally with the data created before the feature exists.
* Another event group can be easily created based on the persisted events.
* We can update events and reproduce states when something unexpected happens. This is sometimes quite hard or impossible when a state-based system is used. This is a bad practice since events should be immutable, but we don't need to be dogmatic unless there are actual concerns.
* Each group does not need to be in the same database unless they are used together. We'd be able to separate out some event groups if required for performance optimization.
