# Summary

## Event Sourcing for Domain Driven Design

objectives

* To persist aggregates
* To overcome the problem of distributed transactions
* To build a reactive event driven system

Some assumptions

* Aggregate is a unit of transaction
* Eventual consistency for availability, performance, and scalability
*

Typical use cases

* Application for frequent writes
* Complex state transition management

If it's for performance, tailor-made optimization such as caching and data modeling is the key. The best solution is different on each use case and no need to put strong constraints Event Sourcing has. If it's for state management, typically, consistency is more important than performance and scalability. Why not choose more predictable approach?

## Essential Elements of Event Sourcing

1. Persisting state transitions as immutable events is the essence of Event Sourcing. Since this is the strongest constraint, an Event Sourcing system should be built for this purpose.
2. Once events are persisted, we can recover any state at a point in time. Projections are event consumers. There are various ways to support this feature. In general, push-based event propagation along with periodical event sync works well. Typically, complex synchronization mechanism is not required since events are immutable though a time lag needs to be tuned up.
3. Each state is associated with a set of events. States in command handlers are generated by dedicated event handlers. This process is also a kind of a projection. We don't necessarily need to reconstruct an entire aggregate since it's only used to generate events or reject a command. Event handlers are pure functions. We can assume that a state can be reliably recovered by replaying events.
4. Many command handlers would need to handle side effects. This needs a deliberate considerations because retrying commands on failure might cause problems. Idempotence and check-pointing are important aspects.
5. States can be cached. Having a snapshot in a database and in memory would be important. If each command is routed to a process that has the cache in memory, it would significantly improve the performance. But this is just for performance optimization.

