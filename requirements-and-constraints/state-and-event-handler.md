---
description: State is only used for command handlers.
---

# State and Event Handler

## Usage of States

We are designing a system that safely and efficiently persist events. The purpose of persisting events is to keep track of all the state transitions. A command handler makes a decision on the state transitions.

A command has information from outside world, an event has information to be persisted.

A command handler is responsible for the transformation. It may consume states for that purpose, and states are only used for that purpose.

(We'll discuss the details on command handlers in [command-handlers-and-side-effects.md](command-handlers-and-side-effects.md "mention"))

## State

A state has information for command handlers. A state is only used to generate events, reject commands, or make side effects (e.g. calling external systems). There is no reason to keep unnecessary information in a state.

~~A state is often called an entity (e.g. `User`) or an aggregate (e.g. `UserList`), which are terms used in the strategic patterns of Domain Driven Design. It can be called an entity because it has a unique identifier. It can be called an aggregate because it's often used as a transaction boundary (see~~ [#transactional-boundary](state-and-event-handler.md#transactional-boundary "mention")~~). But there are several important differences from the usage of these patterns in the Object Oriented Programming and Domain Driven Design context.~~

## Event Handler

A state gets generated by replaying events with an event handler. The initial state is predefined by developers. The state v1 is generated by applying the event handler to the initial state and an event v1.

`state_n = foldLeft( state_0 )( (previousState, event) => eventHandler(previousState, event) )`

Event handlers should only depend on given state and event. This constraint ensures that states are safely reproduced even after a long time. Since events are immutable and never lost, those states also never change unless there's a change in the event handlers.

## Summary

When we develop traditional systems, we spend a lot of time managing states; schema design, schema updates, data mapping inside code, data migration, transaction management, query building , testing, debugging, ... Though most developers say it's easy to create a CRUD application, it could easily get more and more complex and end up to be a huge state that nobody can fully understand.

By using Event Sourcing, you can focus on essential design. Commands and events are simple enough to be represented as JSON. At the beginning, you can write down required information on parper. For example, `RegisterUser` -> `UserRegistered`, `UploadPicture` -> `PictureUploaded` , Register`Address` -> `AddressRegistered`, `RegisterCard` -> `CardRegistered`, ... States can be defined when some information is required to write a command handler later. You can quickly start using projections to consume the events. Of cource, these data models would need some changes to support some constraints and aggregations. But compared to the traditional development approach, you'd be able to focus more on essential problems that need to be solved.
