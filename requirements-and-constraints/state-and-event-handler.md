# State and Event Handler

## Why not use Command Sourcing?

Command Sourcing stores commands. Our system reacts to each command. If we store the commands, we can replay whatever happened in the past. Is that so? As you can imagine, side effects in command hanlders are the major problem. What if a command handler calls external services to register some information? How about queries? How does it replay commands?

This is why Event Sourcing is chosen. An event can contain information of request, responses from external systems, and results of computation. It's easy to keep these events and cache states. We can safely and efficiently persist events. We can keep track of all the inputs that caused state transitions.

(We'll discuss the details on command handlers in [command-handlers-and-side-effects.md](command-handlers-and-side-effects.md "mention"))

## State

A command handler receives a command and generate events or reject the command. A state is just an intermediate state in memory and only used for command handlers. States are just a part of the command handler process.

We can update states flexibly along with command handlers. Though we cannot change facts, we can change the interpretation of the facts and how we behave based on that.

## Event Handler

A state gets generated by replaying events with an event handler. The initial state is predefined by developers. The state v1 is generated by applying the event handler to the initial state and an event v1.

`state_n = foldLeft( state_0 )( (previousState, event) => eventHandler(previousState, event) )`

Event handlers should only depend on given state and event. This constraint ensures that states are safely reproduced even after a long time. Since events are immutable and never lost, those states also never change unless there's a change in the event handlers.

## How do we design events?

Basically, the database only stores events. Events should contain all the information we want to preserve which is information that cannot be recovered later. We would want commands, responses from external systems, and the results of decisions made by command handlers to be stored. Since we have all required information, what Command Sourcing tried to achieve can be done by this design.

Of course, events capture state transitions. But events can also capture all inputs to the system. By doing that, we can understand what happened to the system without causing side effects.

We introduced the concept of Event Group. Multiple states can share the same event group. When loading events, the event handler for each state can only pick up events it is interested in.

Command Handlers

Command handlers make decisions based on the states. It's natural for command handlers to change behaviors in future, if we change how we view past events.

For consistency, before writing an event all the previous events for the event group need to be read (most of them can be cached as a state snapshot).&#x20;

## Summary

When we develop traditional systems, we spend a lot of time for managing states; schema design, schema updates, data mapping inside code, data migration, transaction management, query building , testing, debugging, ... Though most developers say it's easy to create a CRUD application, the system could easily get more and more complex and end up to be a huge state that nobody can fully understand. It causes problems, which requires non-trivial amount of time. Also, testing these applications, especially managing test data, is one of the hardest problems in development.&#x20;

By using Event Sourcing, you can focus on essential design. Commands and events are simple enough to be represented as JSON. At the beginning, you can write down required information on parper. For example, `RegisterUser` -> `UserRegistered`, `UploadPicture` -> `PictureUploaded` , Register`Address` -> `AddressRegistered`, `RegisterCard` -> `CardRegistered`, ... States can be defined when some information is required to write a command handler later. You can quickly start using projections to consume the events. Of cource, these data models would need some changes to support some constraints and aggregations. But compared to the traditional development approach, you'd be able to focus more on essential problems that need to be solved.
