# Event Store

## Overview

An event store is a storage service that preserves events. Design of the event store defines most of the functionalities of the Event Sourcing system.

## Event Reads

There are mainly two types of event queries.

### Summary Query

A summary gets generated by aggregating all events for the summary. Query example:

```
SELECT version, data FROM event
WHERE group = 'user' and id = 'user123'
ORDER BY version;
```

### Projection Query

A projection reads a group of events. Since a projection does not know persisted summary IDs in advance, it needs to scan through the events without specifying IDs. Query example:

```
SELECT id, version, data FROM event
WHERE group = 'user'
ORDER by version;
```

The version can be used to record the position of the event consumption.

### (Optional) Projection Query for multiple summary groups

When multiple groups of events need to be consumed by a single projection, the version column cannot be used because versions are managed for each summary group. Another column for sorting such as a sequential ID or timestamp is required. Example:

```
SELECT group, id, timestamp, data FROM event
WHERE group IN ('user', 'group')
ORDER by timestamp;
```

## Event Write

### Data Schema

An example table definition for Postgresql:

```
CREATE TABLE IF NOT EXISTS event (
  group      TEXT         NOT NULL,
  id         TEXT         NOT NULL,
  version    BIGINT       NOT NULL,
  data       JSONB        NOT NULL,
  seq        BIGSERIAL    NOT NULL UNIQUE,
  created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC'),
  PRIMARY KEY (group, id, version)
);
```

Insert query:

```
INSERT INTO event (
  group, id, version, data
) VALUES (
  'user', 'user123', 3, '{"_name": "EmailUpdated", "email": "foo@..."}'
);
```

The version column needs to be generated on the application side to detect a conflict. To increment the version, the application needs to read all the events for the summary.

This INSERT query fails if there is a record with the same primary keys. This kind of `INSERT ... IF NOT EXISTS` is supported by most databases. This simple query is sufficient enough to detect a conflict for a single summary.

### (Optional) Atomic Write

An atomic batch write is required to support writing multiple events generated from a single command. This is supported by RDBMS as `INSERT INTO event (...) VALUES (...), (...);`.  However, not all databases support this feature. For example, though Cassandra supports a batch write and conditional insertion, a conditional batch write is only supported for a single partition.

### (Optional) Transactions

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

A transaction can be used to prevent concurrent executions of command handlers for specific summaries. For instance, `SELECT ... FOR UPDATE` can be used.

The biggest benefit of using a transaction is to prevent concurrent executions of side effects to external systems. These side effects cannot be reverted even when an event write fails due to a conflict.

### (Optional) Snapshot

For performance and efficiency, a snapshot of a summary can be persisted separately. We can simply overwrite a summary in another table every N events. In this case, the consumer needs to make at least two queries: a snapshot read and succeeding event reads.
