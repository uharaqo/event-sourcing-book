# Event Store

## Overview

An event store is a storage that preserves events. Design of the event store mostly defines functionalities offered to the Event Sourcing system.

## Event Reads

There are mainly two types of event queries.

### Summary Query (summary group and summary id)

A summary gets generated by aggregating all events for the summary. Query example:

`SELECT version, data FROM event WHERE group = 'user' and id = 'user123' ORDER BY version;`

### Projection Query (summary groups)

A projection reads a group of events. Since a projection does not know persisted IDs in advance, it needs to scan through events. Query example:

`SELECT id, version, data FROM event WHERE group = 'user' ORDER by version;`

The version can be used to record the position of the event consumption.

### (Optional) Projection Query for multiple summary groups

When multiple groups of events need to be consumed by a single projection, the above projection query is not sufficient because events can only be sorted by versions within each summary group. This can be supported by adding an sequential ID or unique timestamp. Example:

`SELECT group, id, timestamp, data FROM event WHERE group IN ('user', 'group') ORDER by timestamp;`

Note that the order of events across multiple groups is not always guaranteed. For instance, Event 1 that happened in a group might be written after Event 2 in another group though Event 1 was generated earlier than Event 2.

## Event Write

### Data Schema

An example table definition for Postgresql:

```
CREATE TABLE IF NOT EXISTS event (
  group      TEXT         NOT NULL,
  id         TEXT         NOT NULL,
  version    BIGINT       NOT NULL,
  data       JSONB        NOT NULL,
  seq        BIGSERIAL    NOT NULL UNIQUE,
  created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT (current_timestamp AT TIME ZONE 'UTC'),
  PRIMARY KEY (group, id, version)
);
```

An insert query would look like this:

```
INSERT INTO event (
  group, id, version, data
) VALUES (
  'user', 'user123', 3, '{"_name": "EmailUpdated", "email": "foo@..."}'
);
```

This simple query is sufficient enough to satisfy the requirement. Since events are immutable and written only once, we don't need complex concurrency control for this purpose. This functionality would be supported by most databases.

### (Optional) Atomic Write

An atomic batch write is required to support writing multiple events generated from a single command. This is supported by RDBMS as `INSERT INTO event (...) VALUES (...), (...);`.  But not all databases support this feature. For example, though Cassandra supports a batch write and conditinoal insertion, both of them can be only used for a single partition.

### (Optional) Transactions

![](<../../.gitbook/assets/image (1).png>)

Most articles say "Event Sourcing systems need to be designed by accepting eventual consistency" and assume no usage of ACID transactions. This is not necessarily true.

As mentioned above, event conflicts can be easily prevented even without transactions. Additionally, by using a transaction we can lock event writes to some specific event groups and also block concurrent invocations of a command handler. Details are discussed in[command-handlers-and-side-effects.md](command-handlers-and-side-effects.md "mention").

## (Optional) Command Chain

![](<../../.gitbook/assets/image (4).png>)

Side effects in a command handler cannot be reverted since we cannot manage external services.&#x20;

### (Optional) Snapshot

For performance and efficiency, a snapshot of summary can be persisted separately. In this case, the consumer needs to make at least two queries: a snapshot read and succeeding event reads.
