# Design Requirements

## Overview

![](<../../.gitbook/assets/image (5).png>)

The system receives a command and looks up the command handler for that. It may read events to generate zero or more summaries. It generates zero or more events, or rejects the command. The emitted events are persisted in a database. Projections can read these events to make side effects such as updating databases or sending events to external systems.

### Event

An event is an immutable record persisted in a database. Events contain all the information selected to keep for the system. Each event has an summary group, summary ID, monotonously increasing version number, and event content. Example: group: `cart`, id: `cartId-123` , version: `5`, content: `{"_name": "ItemAdded", "itemId": 41, "count": 2}`

### Summary Group

!!! Is it a summary group or summary group + id that controls v1 v2 ... ? !!!

Summary group represents a transaction boundary. Event versions should monotonously increase in the insertion order within the same summary group and summary ID.

Insertion order of events across multiple summary groups is not accurately preserved though it can be roughly sorted by timestamps. (In general, clocks are not accurate.)

For consistency, all the previous events for a summary group need to be read before writing a new event.

### Projection

Projection is an event consumer. Projections can be used to run side effects based on persisted events (e.g. updating a table, sending an email). Since each event is immutable and has a unique version, they can be safely consumed concurrently as many times as required. Typically, projections are handled by separate processes for scalability and designed under eventual consistency and at-least-once semantics.

### Command

An input from the outside world. It's a request to change the system's internal state and/or to make side effects. It's mostly the same as typical HTTP POST / PUT requests.

### Command Handler

Recieves a command and generate events or rejects the command. It may consume summaries and call external systems. We have no constraints for command handlers at this point.&#x20;

### Summary

A summary is an interpretation of events. It is generated by aggregating events by the `foldLeft` function with an event handler. Summaries are only used for command handlers.

### Event Handler

Generates the next summary by consuming the next event and the previous summary. It should be a pure function that has no side effects.

`summary_n = foldLeft( summary_0 )( (previousSummary, event) => eventHandler(previousSummary, event) )`

The initial summary is predefined by developers. The initial summary and an event v1 generate a summary v1, and the summary v1 and an event v2 generate summary v2, and so on.&#x20;

Event handlers should only depend on given state and event. This constraint ensures that summaries are safely reproduced even after a long time. Since events are immutable and never lost, those summaries also never change as long as there's no change to the event handlers.
