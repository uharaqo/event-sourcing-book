# What is Event Sourcing?

## This is not a book about THE Event Sourcing

I checked many articles, videos, and libraries on Event Sourcing. I joined some Event Sourcing courses including Greg Young's. But I felt that the design is too complicated. There are too many things to consider even for simple features.

I noticed that the complexity does not come from the core Event Sourcing concept but from their design choices:

* A state is a [DDD aggregate](https://martinfowler.com/bliki/DDD\_Aggregate.html)
* Command handlers do not use transactions

By removing these assumptions, we can design a system that can solve most of the problems related to the Event Sourcing design.

In this series of short articles, we will design an Event Sourcing system without these assumptions. The simple and reasonable design will provide variety of implementation patterns to us.

## Event Sourcing Overview

![](<../.gitbook/assets/image (9).png>)

Event Sourcing stores `events` in a database. Events are facts that happened in the past. Facts are immutable; once they are recorded, they are never updated. In case we find a false fact, we don't remove the record but record a new fact that corrects the previous fact. Events are stored as serialized data (e.g. JSON or protobuf).

By aggregating the events, we can deduce variety of information. This process is called a `projection` . By running a projection, we can update a database to maintain `summaries` (also called as `states` or `read models`) of the events, or propagate the events to other systems. These `summaries` can be exposed as `query` APIs. Event Sourcing don't put any constraints to the design of projections and summaries.

`Command handlers` receive an update request from the external world and generate events or reject the command. The update request is called a `command`.

In most cases, command handlers depend on some summaries. Summaries for command handlers are generated by a simple `foldLeft` function. A function passed to the foldLeft function is called an `event handler` which is a pure function that does not access any external state.

`summary_n = foldLeft( summary_0 )( (previousSummary, event) => eventHandler(previousSummary, event) )`

By using Event Sourcing, we can develop an application driven by essential design elements: events (information that needs to be preserved), commands (information from the external world), command handlers (business rules), and projections for query APIs.

## Pros

### Persist state transitions instead of latest state

A system changes its behaviors based on its internal state. The state needs to be persisted in an external database for state recovery. Access to the state requires coordination such as ACID transactions for consistency. This is a widely used design approach.

Typically, the database only keeps the latest state. The state transitions are managed by both application and database. Typically, this is the most complicated, time-consuming, and error-prone part of the application.

Event Sourcing simply stores serialized events and generates summaries by aggregating events. Instead of spending lots of time on database management, we can focus on essential design of the system.

### Immutable events&#x20;

Events are immutable. Summaries generated from the events are also immutable. This makes it easier to reason about the behaviors of the system.

Events can be safely shared with multiple systems at the same time. By adding projections, we can easily integrate variety of systems such as RDBMS, key-value store, search engine, graph database, message queue, and so on.

### Simple data schema

Only a single table is required to store events. Replicating the database is quite easy. This can resolve one of the hardest problems in development: integration test and test data management.  We can easily clone database  to develop, debug, and troubleshoot the application.

### Simple Design

Information from external systems is represented as commands. Information persisted in the system is represented as events. A common serialization protocol such as JSON or Protobuf can be used. We can simply define commands and events.

Projections for queries are separated from the command handler process. We can flexibly add query APIs and backend databases.

Command handlers are the core process of the system that represents business rules. Code that generates events based on a command and states is typically straight-forward.

Tests become quite simple. Basically, we just need to send commands and validate emitted events and generated summaries.

Even non-engineers can easily understand the design concept. This fits well with the strategic patterns of Domain Driven Design, which encourages collaboration of domain experts and engineers. A design approach called Event Storming is a great example.

## Cons

### Too strong constraints

Most articles on Event Sourcing puts too strong assumptions such as

* a command handler can only use a single state (summary)
* a command handler can only emit a single event
* a command handler can only emit an event for the given state
* a command handler cannot use a transaction to prevent duplicated side effects
* the backend database should be a simple key-value store or equivalent

These are not requirements of Event Sourcing. Many difficult problems in Event Sourcing are caused by these choices. We will discuss how to remove these constraints by design.

### Eventual Consistency

Projections need to be eventually consistent. This is the first problem most people question about. But there are solutions in most cases. For instance, a timestamp or version can be added to queries to make sure that the response is the latest summary.

Most Event Sourcing systems don't support transactions, which means that multiple summaries (states) cannot be updated consistently. This problem can be simply solved by using a transaction. We will discuss this in the following chapters.

### Too complicated for simple CRUD systems

Most articles introduces solutions such as [the Saga pattern](https://microservices.io/patterns/data/saga.html). Apparently, it's too complicated to be used as a common pattern inside a single application. Another example is constraints such as unique keys and foreign keys which can be easily supported by RDBMS.

By removing the constraints mentioned above, most of those problems can be easily solved.

### Fear, Uncertainty, Doubt

I was skeptical on Event Sourcing in the beginning, but after spending one year for examining the design from various perspectives, I found out that this can solve variety of problems in development.

The FUD comes mostly from the complicated design and too strong constraints. For instance, imagine that you are implementing a `RegisterUser` command and you need to make sure that email address is unique. You wouldn't be able to easily find a solution for this on the Internet, or that solution would look too complicated compared to a typical RDB-based application.

In this book, we will design much simpler Event Souricing system from scratch that can solve wider problems with simpler implementation.
