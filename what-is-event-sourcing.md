# What is Event Sourcing?

## This is not a book about THE Event Sourcing

I checked many articles, videos, and libraries on Event Sourcing. I joined some Event Sourcing courses including Greg Young's. But I felt that the proposed designs are too complicated. There are too many things to consider even for simple features.

I noticed that the complexity is not coming from the core Event Sourcing concept but from their design choices:

* A state is a [DDD aggregate](https://martinfowler.com/bliki/DDD\_Aggregate.html)
* Command handlers do not use transactions

By removing these assumptions, we can design a system that can solve most of the problems related to the Event Sourcing design.

In this series of short articles, we will design an Event Sourcing system without these assumptions. The simple and reasonable design will provide variety of implementation patterns to us.

## Event Sourcing Overview

<figure><img src=".gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

Event Sourcing stores `events` in a database. Events are facts that happened in the past. Facts are immutable; once they are recorded, they are never removed or updated. In case we find a false fact, we don't remove the record but make a "compensation": append a new fact that corrects the previous fact. Events are stored as serialized data (e.g. JSON or protobuf).

By aggregating the events, we can deduce variety of information. This process is called a `projection` . By running a projection, we can make side effects such as a database update or event propagation to external systems. The database maintained by projections are often called `read models` since the aggregated data is often exposed by query APIs. Event Sourcing don't put any constraints to the design of these projections.

`Command handlers` receive a `command` (update request) from outside the system and generate events or reject the command. In most cases, a command handler depends on a specific state. A state is generated by a simple `foldLeft` function. A function passed to the foldLeft function is called an `event handler` which is a pure function that does not access any external state.

`state_n = foldLeft( state_0 )( (previousState, event) => eventHandler(previousState, event) )`

By using Event Sourcing, we can develop an application driven by essential design elements: events (information that needs to be preserved), commands (information from the external world), command handlers (business rules), and projections for query APIs.

## Pros

### Record state transitions instead of managing latest state

Most applications run are designed to run on multiple processes. Since the processes are volatile, states that change applications' behaviors need to be persisted in an external storage.

Typically, ACID transactions are used to query and mutate the state in a database. Processes share the latest state in the database. Management of transactions, data mappings, and data schemas are not trivial. Since most developers use libraries and tools for these, data accessors tends to become the core part of the application's design.

The database maintains the system's latest state and multiple processes can query and mutate the state. Timing of each operation is quite important and it cannot be easily separated from the application. It's not easy to understand the applications behaviors without having the database with actual data and running the application concurrently. The database is a huge shared state.

Event Sourcing simply stores serialized events and generates states by aggregating them. Each event has a timestamp. We have more control over time. There are variety of use cases:

* Recover a state at a specific point in time by aggregating events
* Check application's behavior with the state
* Replicate the events to a local machine and debug the behavior
* Check the application by modifying the events locally
* Add a new feature and test it by using past events
* Update a projection to regenerate a read model by consuming past events
* Add a new data pipeline by consuming past events
* Add a projection for a new requirement such as RDBMS, key-value store, search engine, graph database, message queue, and so on

### Simple data schema

Only a single table is required to store events. Replicating the database is quite easy. This can resolve one of the hardest problems in development: integration test and test data management.  The production database can be easily cloned to a local machine to develop, debug, and troubleshoot the application.

### Simple Design

Information from outside the systems is represented as commands. Information persisted in the system is represented as events. A common serialization protocol such as JSON or Protobuf can be used. We can simply define commands and events. Query APIs can be flexibly designed because projections are separated from the command handler process.

This reasonable design simplifies the implementation and developers can focus on the design of data models and workflows.

Testing also becomes simple and straight-forward because input (command and previous state) and output (events and latest states) are standardized. Setting up test data is also easy.

Even non-engineers can easily understand the design concept. This fits well with the strategic patterns of Domain Driven Design, which encourages collaboration of domain experts and engineers. A design approach called Event Storming is a great example.

### Typical Use Cases

Event Sourcing is often used to maximize performance for write-heavy application. Event writes can be implemented as a single-key conditional insertion which does not require distributed coordination.

Another common use case is workflow management tool. Since Event Sourcing is designed as an event driven system, it fits well for a system that requires complex state management.

## Cons

### Too strong constraints

Most Event Sourcing design puts some common constraints such as:

* a command handler can only use a single state
* a command handler can only emit a single event
* a command handler can only emit an event for the given state
* a command handler cannot use a transaction to prevent duplicated side effects
* the backend database should be a simple key-value store or equivalent

By accepting these constraints, these Event Sourcing systems can handle complex write-heavy workload.

However, these constraints become obstacles for designing even a simple application such as a common CRUD system. For instance, unique key or foreign key constraints cannot be easily implemented. This is why Event Sourcing is said to be a design for complex use cases.

In this series of articles, we are going to design a system without these constraints. Although the write performance might deteriorate, the design will remove most of the problems associated with Event Sourcing and support various use cases.

### Eventual Consistency

Projections need to be eventually consistent. This is the first problem most people question about. If this is critical for the application, Event Sourcing would not be a good solution. In most applications, this is not a major constraint. For instance, it might be sufficient enough if the lag is tens of milliseconds or if there is an option to wait for an update to be reflected.

Most Event Sourcing systems don't support ACID transactions, which means that there is no guarantee on updates to multiple states. This problem can be simply solved by using a transaction. We will discuss this in the following chapters.

### Too complicated for simple CRUD systems

The lack of transaction requires alternative approaches to manage updates to multiple states. Most articles introduces complex solutions such as [the Saga pattern](https://microservices.io/patterns/data/saga.html) for this purpose. Apparently, it's too complicated to be casually used inside a single application.

By removing the constraints mentioned above, most of those problems can be easily solved.

### Fear, Uncertainty, Doubt

I was skeptical on Event Sourcing in the beginning. A typical CRUD system cannot be easily implemented. For instance, how can we ensure the uniqueness of `email` field in a `RegisterUser` command? There is no simple solution even for such a common use case. This is because of the constraints mentioned above.

Eventual consistency was another concern. When designing an application with NoSQL, most developers use strong consistency for some critical paths while keeping others eventually consistent. We would be able to design a system, but maintaining such a system is a challenge since managing implicit constraints is quite hard. Any breaking change could make the entire system into an unexpected state.

Typically, the trade off between consistency and performance is not the same for all the commands in a system. It's common to optimize the performance of some frequently requested commands while prioritizing consistency for the other commands. It totally makes sense to use a transaction even by blocking some other command handlers if the consistency is more important than performance. If we can easily control this trade off, we will be able to support more use cases.

This is the reason why I started designing Event Sourcing from scratch. Managing multiple states with tunable consistency is the goal. After examining the design from various angles, I discovered that the constraints are not necessarily required for Event Sourcing.

From the next chapter, we check constraints and available design options for each concept. As a result, we will have several design choices to build up a new Event Sourcing system.
