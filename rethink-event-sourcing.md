# Rethink Event Sourcing

## Core Concept: foldLeft

The idea behind Event Sourcing is quite simple. We store information to be preserved as events. We can deduce information at a specific point in time by aggregating all the past events with the `foldLeft` function:

`summary_n = foldLeft( summary_0 )( (previousSummary, event) => eventHandler(previousSummary, event) )`

The event handler generates the next version of a summary based on the previous summary and the next event.

Typical applications maintain its latest state in a database.&#x20;

## Basic Event Requirements

### How about Command Sourcing?

Let's assume that we have an permanent event queue for commands. Can we easily run the command processors by replaying the commands? It is difficult due to command handlers' side effects. For instance, what happens if a command handler depends on a response from an external system or mutate an external state? The outcome becomes different every time we replay commands.

This is why we store events. Each event can contain data including a command and responses from external systems. By encapsulating the unrecoverable information at the time and store it permanently, we can acquire an ability to rewind the time.

### Grouping of Events

A typical system maintains its state in a database. The system reacts to inputs based on the state. On the other hand, an Event Sourcing system stores immutable events. To provide the same functionalities as typical systems, the events need to have all the required information for the system. The events are consumed by a command handler as a summary of events that gets generated by the `foldLeft` function. The summary contains information required for the command handler.

Events are grouped by a `summary`. For instance, events for a user 'alice' can be grouped by a 'user' summary. We should ensure that the 'user' summary for 'alice' can be reliably generated at any time.

* Events are immutable
* Each event is associated with a specific summary
* Each summary has a `summary ID` (e.g. '123' or 'alice')
* Events to generate a specific summary can be retrieved in the inserted order
* The latest summary generated from all the past events should be used to generate the next event

What if we only have a single huge summary for the entire system. We wouldn't lose any functionalities because of this, but we will face some problems. Write performance won't scale out since only one update can be accepted at a time. All the events need to be read and the huge summary needs to be constructed on memory. This is the technical reason for having summary IDs.

What if an event handler accesses external states? The `foldLeft` function becomes unstable and unrepeatable. The outcome can become unpredictable. Events can be safely replicated and cached. So are the summaries generated from the events. This assumption is based on the immutability of the events and side-effect free event handlers.

* An event handler should only depend on given summary and events; it should not access external states

To implement a projection, we want a filtering condition to scan through events without using summary IDs.

* Summaries are grouped by a `summary group` (e.g. 'user')

### Event Insertion

In general, concurrent updates for a single summary must be prevented since it makes the outcome unpredictable. There are several solutions:

* Use a conditional insertion (CAS). This is supported by most databases.
* Use a pessimistic lock such as a transaction.
* Route a command to the command handler in a specific process

Apparently, the first solution is the easiest, and the last one is the hardest. Though the use of transactions limits the choices of a database, it provides additional functionalities to the system. Let's assume that we use the first solution and consider pessimistic locks later.&#x20;

### "State" is not so important

Other Event Sourcing systems put much more emphasis on a state (we call it a summary). Most of those systems use Event Sourcing to backup and recover application's state. These are the assumptions those systems have in common:

* Each command handler is associated with a single state
* An event is a state transition (i.e. information required to update the current state to the next state)
* A command handler can only generate a single event for the state

But we have not seen any reasons to put these assumptions and constraints. A state (summary) is just information on memory only required for command handlers. They are literary immutable summaries of events to skip reading the past events every time. Let's put more emphasis on events and less emphasis on state.

* A command handler can consume multiple summaries
* A command handler can generate events for multiple summaries
* An event is information we want to preserve
* A summary is only used by command handlers. It only needs to have information required for a command handler

We receive a command that has information from outside the system and looks up the command handler for the command. The command handler fetches some summaries and generate events. The events are persisted for the next command and for projections.

This generalization requires a way to manage consistency across multiple summaries but provides many powerful features to design a system.

Even at this point, the design we discussed is quite different from typical Event Sourcing designs. I summarized what we have discussed so far in the next page.
