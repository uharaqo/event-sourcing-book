# Proposed Development Process

## 1. Define Command

A command is an input from outside the system. The basic idea is same as typical HTTP POST / PUT requests. Example:

```
{
  "_type": "RegisterUser",
  "name": "Alice",
  "email": "alice@..."
}
```

## 2. Define Event

An event contains information to be preserved. Events are generated by a command handler and stored after serialization.

```
{
  "_type": "UserRegistered",
  "name": "Alice",
  "email": "alice@...",
  "serial": 194832048431 // fetched from an external service
}
```

Most articles on Event Sourcing regards an event as a state transition and only accepts an event associated with the state for the command handler. The proposed design can access multiple states and no constraint on events. Each event may contain any information such as the received command, responses from external services, or generated IDs.

## 3. Implement Command Handler

A command handler receives a command and summary of events to generate 0 or more events or reject the command.

```
val registerUser =
  commandHandlerFor[RegisterUser, UserRegistered, User] { (c, s, ctx) =>
    s match {
      case User.EMPTY =>
        val serial = UserService.newSerial(c.email) // external call
        ctx.save( UserRegistered.from(c, serial) )
      case _ =>
        ctx.failure( InvalidState.create("Already Registered") )
  }
```

Unlike other Event Sourcing designs, the proposed design provides a way to access multiple states. It also provides a way to control transactions.

TODO: example to use a transaction

## 4. Implement Summary and Event Handler

The previous command handler changes its behaviors based on the `User` summary. In this example, let's assume that we want to use the email for other commands. We can add more fields to this summary if we want in future.

```
class User(email: String)

object User:
  val EMPTY = new User("")
```

An event handler receives an event and summary and generate the next summary. It should not depend on other information or throw any exception to make this process reliable.

```
val eventHandler =
  eventHandlerFor[UserRegistered, User] { (e, s) =>
    s match
      case User.Empty => new User(e.email)
      case _ => s
  }
```

## 5. Testing

Testing is straightforward; send a command and validate the generated events and summary.

```
tester
  .command( RegisterUser("Alice", "alice@...") )
  .events( UserRegistered("Alice", "alice@...", 194832048431) )
  .summary( new User("alice@...") )
```

## 6. Implement Projections

Projections are optional event consumers that are executed as separate processes. There is no constraints on projections.

```
val userProjection =
  projectionFor[UserEvent] { e =>
    e match {
      case RegisterUser => db.update(e)
    }
  }
```

Query APIs can be provided by using the updated DB.

## Advanced Patterns

### Atomic Writes

Let's assume that an email address should be used only once for registration. We can emit an `EmailRegistered` event with the email as a key along with the `RegisterUser` event. In the command handler, we can lookup the `RegisteredEmail` summary that is generated from 0 or 1 `EmailRegistered` event.

### Transactions

By using a transaction, we can solve many problems that cannot be easily supported by other Event Sourcing designs. See [#optional-transactions](event-store.md#optional-transactions "mention") and [#command-chain](command-handlers-and-side-effects.md#command-chain "mention").

## Event Storming

[Event Storming](https://www.ibm.com/cloud/architecture/architecture/practices/event-storming-methodology-architecture/) is a workshop format for quickly exploring complex business domains. Commands and events are simple enough to be casually used in a design discussion. [A simple diagram like this](https://kalele.io/a-blended-diagramming-style/) will represent essense of the system design. Event Sourcing helps us develop a system driven by design.
